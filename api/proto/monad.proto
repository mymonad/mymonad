syntax = "proto3";

package monad;

option go_package = "github.com/mymonad/mymonad/api/proto";

// MonadStore is the IPC service exposed by the Ingestion Daemon.
service MonadStore {
  // GetMonad returns the current encrypted Monad.
  rpc GetMonad(GetMonadRequest) returns (GetMonadResponse);

  // WatchMonad streams updates when the Monad changes.
  rpc WatchMonad(WatchMonadRequest) returns (stream MonadUpdate);

  // Status returns the ingestion daemon status.
  rpc Status(StatusRequest) returns (StatusResponse);
}

message GetMonadRequest {}

message GetMonadResponse {
  bytes encrypted_monad = 1;
  int64 version = 2;
  int64 last_updated = 3; // Unix timestamp
}

message WatchMonadRequest {}

message MonadUpdate {
  bytes encrypted_monad = 1;
  int64 version = 2;
  int64 timestamp = 3;
}

message StatusRequest {}

message StatusResponse {
  bool ready = 1;
  int64 documents_indexed = 2;
  int64 last_scan_timestamp = 3;
  string state = 4; // "idle", "scanning", "embedding"
}

// AgentService is the IPC service exposed by the Agent Daemon.
service AgentService {
  // Status returns the agent's current status.
  rpc Status(AgentStatusRequest) returns (AgentStatusResponse);

  // Peers returns connected peers.
  rpc Peers(PeersRequest) returns (PeersResponse);

  // Bootstrap manually connects to a peer.
  rpc Bootstrap(BootstrapRequest) returns (BootstrapResponse);

  // Identity returns the local identity info.
  rpc Identity(IdentityRequest) returns (IdentityResponse);

  // Handshake operations
  rpc StartHandshake(StartHandshakeRequest) returns (StartHandshakeResponse);
  rpc ListHandshakes(ListHandshakesRequest) returns (ListHandshakesResponse);
  rpc GetHandshake(GetHandshakeRequest) returns (GetHandshakeResponse);
  rpc ApproveHandshake(ApproveHandshakeRequest) returns (ApproveHandshakeResponse);
  rpc RejectHandshake(RejectHandshakeRequest) returns (RejectHandshakeResponse);
  rpc WatchHandshakes(WatchHandshakesRequest) returns (stream HandshakeEvent);
}

message AgentStatusRequest {}

message AgentStatusResponse {
  bool ready = 1;
  string peer_id = 2;
  int32 connected_peers = 3;
  int32 active_handshakes = 4;
  string state = 5;
}

message PeersRequest {}

message PeersResponse {
  repeated PeerInfo peers = 1;
}

message PeerInfo {
  string peer_id = 1;
  repeated string addrs = 2;
  string connection_state = 3;
}

message BootstrapRequest {
  string multiaddr = 1;
}

message BootstrapResponse {
  bool success = 1;
  string error = 2;
  string peer_id = 3;
}

message IdentityRequest {}

message IdentityResponse {
  string peer_id = 1;
  string did = 2;
  repeated string listen_addrs = 3;
}

// Handshake messages

message StartHandshakeRequest {
  string peer_id = 1;
}

message StartHandshakeResponse {
  string session_id = 1;
  string error = 2;
}

message ListHandshakesRequest {}

message ListHandshakesResponse {
  repeated HandshakeInfo handshakes = 1;
}

message GetHandshakeRequest {
  string session_id = 1;
}

message GetHandshakeResponse {
  HandshakeInfo handshake = 1;
  string error = 2;
}

message HandshakeInfo {
  string session_id = 1;
  string peer_id = 2;
  string state = 3;
  string role = 4;
  int64 elapsed_seconds = 5;
  bool pending_approval = 6;
  string pending_approval_type = 7;
}

message ApproveHandshakeRequest {
  string session_id = 1;
  // For unmask approval, include identity to reveal
  string display_name = 2;
  string email = 3;
  string signal_number = 4;
  string matrix_id = 5;
}

message ApproveHandshakeResponse {
  bool success = 1;
  string error = 2;
}

message RejectHandshakeRequest {
  string session_id = 1;
  string reason = 2;
}

message RejectHandshakeResponse {
  bool success = 1;
  string error = 2;
}

message WatchHandshakesRequest {}

message HandshakeEvent {
  string session_id = 1;
  string event_type = 2;  // "started", "stage_changed", "pending_approval", "completed", "failed"
  string state = 3;
  string peer_id = 4;
  int64 elapsed_seconds = 5;
}
